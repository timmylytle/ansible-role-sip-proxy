#!KAMAILIO
#
# Kamailio Config generated by Ansible
# This config supports a private sip proxy behind NAT that loadbalances to private SIP endpoints
#
#
####### Defined Values #########
# *** Value defines - IDs used later in config
#!define MULTIDOMAIN 0
#!define FLT_ACC 1
#!define FLT_ACCMISSED 2
#!define FLT_ACCFAILED 3
#!define FLT_NATS 5
#!define FLB_NATB 6
#!define FLB_NATSIPPING 7
#
#!define DBURL "postgres://{{ dbuser_kam }}:{{ dbpass_kam }}@{{ dbhost }}:{{ dbport }}/{{ db_kam }}"
#!define DS_SET {{ disp_set }}}
#!define DS_ALG {{ disp_alg }}
#
####### Global Parameters #########
debug={{ debug_level }}
log_stderror={{ log_stderror }}
log_facility=LOG_LOCAL0
log_prefix="{$mt $hdr(CSeq) $ci} "
#
/* define interfaces to bind to */
listen=udp:{{ private_ip_address }}:{{ sip_udp_port }} advertise {{ public_ip_address }}:{{ sip_udp_port }}
listen=tcp:{{ private_ip_address }}:{{ sip_tcp_port }} advertise {{ public_ip_address }}:{{ sip_tcp_port }}
tcp_connection_lifetime={{ tcp_connection_lifetime }}
tcp_max_connections={{ tcp_max_connections }}
#
{% if enable_jsonrpc == true %}tcp_accept_no_cl=yes{% endif %}
{% if enable_tls == true %}enable_tls=yes
tls_max_connections={{ tls_max_connections }}{% endif %}
#
####### Modules Section ########
{% if enable_jsonrpc == true %}loadmodule "xhttp.so"{% endif %}
loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "textopsx.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"
loadmodule "counters.so"
loadmodule "nathelper.so"
loadmodule "rtpproxy.so"
{% if enable_tls == true %}loadmodule "tls.so"{% endif %}
{% if enable_anitflood == true %}loadmodule "htable.so"
loadmodule "pike.so"{% endif %}
{% if enable_debug == true %}loadmodule "debugger.so"{% endif %}
loadmodule "db_postgres.so"
loadmodule "dispatcher.so"
#
# ----------------- setting module-specific parameters ---------------
modparam("jsonrpcs", "pretty_format", 1)
{% if enable_jsonrpc == true %}modparam("jsonrpcs", "transport", 7){% endif %}
modparam("sanity", "autodrop", 0)
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)
modparam("rr", "enable_full_lr", 0)
modparam("rr", "append_fromtag", 0)
modparam("registrar", "method_filtering", 1)
modparam("registrar", "max_expires", 3600)
modparam("registrar", "gruu_enabled", 0)
modparam("registrar", "use_path", 1)
modparam("registrar", "path_mode", 0)
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
modparam("acc", "detect_direction", 0)
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "log_missed_flag", FLT_ACCMISSED)
modparam("acc", "log_extra",
        "src_user=$fU;src_domain=$fd;src_ip=$si;"
        "dst_ouser=$tU;dst_user=$rU;dst_domain=$rd")
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
modparam("usrloc", "timer_interval", 60)
modparam("usrloc", "timer_procs", 1)
modparam("usrloc", "use_domain", MULTIDOMAIN)
modparam("usrloc", "db_url", DBURL)
modparam("usrloc", "db_mode", 2)
modparam("rtpproxy", "rtpproxy_sock", "udp:127.0.0.1:7722")
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
modparam("nathelper", "sipping_from", "sip:pinger@kamailio.org")
modparam("nathelper|registrar", "received_avp", "$avp(RECEIVED)")
modparam("usrloc", "nat_bflag", FLB_NATB)
{% if enable_tls == true %}modparam("tls", "config", "/usr/local/etc/kamailio/tls.cfg"){% endif %}
{% if enable_anitflood == true %}modparam("pike", "sampling_time_unit", {{ pike_sample_time }})
modparam("pike", "reqs_density_per_unit", {{ pike_reqs_density }})
modparam("pike", "remove_latency", {{ pike_remove_latency }})
modparam("htable", "htable", "ipban=>size=8;autoexpire={{ ipban_expire }};"){% endif %}
{% if enable_debug == true %}modparam("debugger", "cfgtrace", 1)
modparam("debugger", "log_level_name", "exec"){% endif %}
modparam("dispatcher", "db_url", DBURL)
modparam("dispatcher", "ds_ping_interval", 10)
modparam("dispatcher", "ds_ping_method", "OPTIONS")
modparam("dispatcher", "ds_probing_threshold", 10)
modparam("dispatcher", "ds_inactive_threshold", 10)
modparam("dispatcher", "ds_ping_latency_stats", 1)
modparam("dispatcher", "ds_probing_mode", 1)
#
####### Routing Logic ########
request_route {

        # per request initial checks
        route(REQINIT);

        # NAT detection
        route(NATDETECT);

        # LOADBALANCE processing
        if(method=="INVITE"){
              ds_select_dst(1, 4);
              record_route();
              route(RELAY);
        }

        # CANCEL processing
        if (is_method("CANCEL")) {
                if (t_check_trans()) {
                        route(RELAY);
                }
                exit;
        }

        # handle retransmissions
        if (!is_method("ACK")) {
                if(t_precheck_trans()) {
                        t_check_trans();
                        exit;
                }
                t_check_trans();
        }

        # handle requests within SIP dialogs
        route(WITHINDLG);

        ### only initial requests (no To tag)

        # authentication
        route(AUTH);

        # record routing for dialog forming requests (in case they are routed)
        # - remove preloaded route headers
        remove_hf("Route");
        if (is_method("INVITE|SUBSCRIBE")) {
                record_route();
        }

        # account only INVITEs
        if (is_method("INVITE")) {
                setflag(FLT_ACC); # do accounting
        }

        # dispatch requests to foreign domains
        route(SIPOUT);

        ### requests for my local domains

        # handle presence related requests
        route(PRESENCE);

        # handle registrations
        route(REGISTRAR);

        if ($rU==$null) {
                # request with no Username in RURI
                sl_send_reply("484","Address Incomplete");
                exit;
        }

        # user location service
        route(LOCATION);
}

# Wrapper for relaying requests
route[RELAY] {

        # enable additional event routes for forwarded requests
        # - serial forking, RTP relaying handling, a.s.o.
        if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
                if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
        }
        if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
                if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
        }
        if (is_method("INVITE")) {
                if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
        }

        if (!t_relay()) {
                sl_reply_error();
        }
        exit;
}

# Per SIP request initial checks
route[REQINIT] {
        # no connect for sending replies
        set_reply_no_connect();
        # enforce symmetric signaling
        # - send back replies to the source address of request
        force_rport();

{% if enable_anitflood == true %}
        # flood detection from same IP and traffic ban for a while
        # be sure you exclude checking trusted peers, such as pstn gateways
        # - local host excluded (e.g., loop to self)
        if(src_ip!=myself) {
                if($sht(ipban=>$si)!=$null) {
                        # ip is already blocked
                        xdbg("request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
                        exit;
                }
                if (!pike_check_req()) {
                        xlog("L_ALERT","ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
                        $sht(ipban=>$si) = 1;
                        exit;
                }
        }
{% endif %}
        if($ua =~ "friendly|scanner|sipcli|sipvicious|VaxSIPUserAgent") {
                # silent drop for scanners - uncomment next line if want to reply
                # sl_send_reply("200", "OK");
                exit;
        }

        if (!mf_process_maxfwd_header("10")) {
                sl_send_reply("483","Too Many Hops");
                exit;
        }

        if(is_method("OPTIONS") && uri==myself && $rU==$null) {
                sl_send_reply("200","Keepalive");
                exit;
        }

        if(!sanity_check("17895", "7")) {
                xlog("Malformed SIP request from $si:$sp\n");
                exit;
        }
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
        if (!has_totag()) return;

        # sequential request withing a dialog should
        # take the path determined by record-routing
        if (loose_route()) {
                route(DLGURI);
                if (is_method("BYE")) {
                        setflag(FLT_ACC); # do accounting ...
                        setflag(FLT_ACCFAILED); # ... even if the transaction fails
                } else if ( is_method("ACK") ) {
                        # ACK is forwarded statelessly
                        route(NATMANAGE);
                } else if ( is_method("NOTIFY") ) {
                        # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
                        record_route();
                }
                route(RELAY);
                exit;
        }

        if (is_method("SUBSCRIBE") && uri == myself) {
                # in-dialog subscribe requests
                route(PRESENCE);
                exit;
        }
        if ( is_method("ACK") ) {
                if ( t_check_trans() ) {
                        # no loose-route, but stateful ACK;
                        # must be an ACK after a 487
                        # or e.g. 404 from upstream server
                        route(RELAY);
                        exit;
                } else {
                        # ACK without matching transaction ... ignore and discard
                        exit;
                }
        }
        sl_send_reply("404","Not here");
        exit;
}

# Handle SIP registrations
route[REGISTRAR] {
        if (!is_method("REGISTER")) return;

        if(isflagset(FLT_NATS)) {
                setbflag(FLB_NATB);
{% if enable_nat_keepalive == true %}
                # do SIP NAT pinging
                setbflag(FLB_NATSIPPING);
{% endif %}
        }
        if (!save("location")) {
                sl_reply_error();
        }
        exit;
}

# User location service
route[LOCATION] {
        $avp(oexten) = $rU;
        if (!lookup("location")) {
                $var(rc) = $rc;
                t_newtran();
                switch ($var(rc)) {
                        case -1:
                        case -3:
                                send_reply("404", "Not Found");
                                exit;
                        case -2:
                                send_reply("405", "Method Not Allowed");
                                exit;
                }
        }

        # when routing via usrloc, log the missed calls also
        if (is_method("INVITE")) {
                setflag(FLT_ACCMISSED);
        }

        route(RELAY);
        exit;
}

# Presence server processing
route[PRESENCE] {
        if(!is_method("PUBLISH|SUBSCRIBE")) return;

        if(is_method("SUBSCRIBE") && $hdr(Event)=="message-summary") {
                sl_send_reply("404", "No voicemail service");
                exit;
        }

        if (is_method("PUBLISH") || $rU==$null) {
                sl_send_reply("404", "Not here");
                exit;
        }
        return;
}

# IP authorization and user authentication
route[AUTH] {
        # authentication not enabled - do not relay at all to foreign networks
        if(uri!=myself) {
                sl_send_reply("403","Not relaying");
                exit;
        }

        return;
}

# Caller NAT detection
route[NATDETECT] {
        if (nat_uac_test("19")) {
                if (is_method("REGISTER")) {
                        fix_nated_register();
                } else {
                        if(is_first_hop()) {
                                set_contact_alias();
                        }
                }
                setflag(FLT_NATS);
        }
        return;
}

# RTPProxy control and signaling updates for NAT traversal
route[NATMANAGE] {
        if (is_request()) {
                if(has_totag()) {
                        if(check_route_param("nat=yes")) {
                                setbflag(FLB_NATB);
                        }
                }
        }
        if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB))) return;

        if(nat_uac_test("8")) {
                rtpproxy_manage("co");
        } else {
                rtpproxy_manage("cor");
        }


        if (is_request()) {
                if (!has_totag()) {
                        if(t_is_branch_route()) {
                                add_rr_param(";nat=yes");
                        }
                }
        }
        if (is_reply()) {
                if(isbflagset(FLB_NATB)) {
                        if(is_first_hop())
                                set_contact_alias();
                }
        }

        if(isbflagset(FLB_NATB)) {
                # no connect message in a dialog involving NAT traversal
                if (is_request()) {
                        if(has_totag()) {
                                set_forward_no_connect();
                        }
                }
        }
        return;
}

# URI update for dialog requests
route[DLGURI] {
        if(!isdsturiset()) {
                handle_ruri_alias();
        }
        return;
}

# Routing to foreign domains
route[SIPOUT] {
        if (uri==myself) return;

        append_hf("P-Hint: outbound\r\n");
        route(RELAY);
        exit;
}

# JSONRPC over HTTP(S) routing
{% if enable_jsonrpc == true %}
event_route[xhttp:request] {
        set_reply_close();
        set_reply_no_connect();
        if(src_ip!=127.0.0.1) {
                xhttp_reply("403", "Forbidden", "text/html",
                                "<html><body>Not allowed from $si</body></html>");
                exit;
        }
        if ($hu =~ "^/RPC") {
                jsonrpc_dispatch();
                exit;
        }

        xhttp_reply("200", "OK", "text/html",
                                "<html><body>Wrong URL $hu</body></html>");
    exit;
}
{% endif %}

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
        xdbg("new branch [$T_branch_idx] to $ru\n");
        route(NATMANAGE);
}

# Manage incoming replies
reply_route {
        if(!sanity_check("17604", "6")) {
                xlog("Malformed SIP response from $si:$sp\n");
                drop;
        }
}

# Manage incoming replies in transaction context
onreply_route[MANAGE_REPLY] {
        xdbg("incoming reply\n");
        if(status=~"[12][0-9][0-9]") {
                route(NATMANAGE);
        }
}

# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
        route(NATMANAGE);

        if (t_is_canceled()) exit;
}